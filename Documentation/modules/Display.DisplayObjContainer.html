<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Shilke2D</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Fields">Fields</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><a href="../modules/Core.Assets.html">Core.Assets</a></li>
  <li><a href="../modules/Core.Event.html">Core.Event</a></li>
  <li><a href="../modules/Core.EventDispatcher.html">Core.EventDispatcher</a></li>
  <li><a href="../modules/Core.IAnimatable.html">Core.IAnimatable</a></li>
  <li><a href="../modules/Core.Juggler.html">Core.Juggler</a></li>
  <li><a href="../modules/Core.Keymap.html">Core.Keymap</a></li>
  <li><a href="../modules/Core.Shilke2D.html">Core.Shilke2D</a></li>
  <li><a href="../modules/Core.Timer.html">Core.Timer</a></li>
  <li><a href="../modules/Core.TouchSensor.html">Core.TouchSensor</a></li>
  <li><a href="../modules/Display.BaseQuad.html">Display.BaseQuad</a></li>
  <li><a href="../modules/Display.BlendMode.html">Display.BlendMode</a></li>
  <li><a href="../modules/Display.Button.html">Display.Button</a></li>
  <li><a href="../modules/Display.DisplayObj.html">Display.DisplayObj</a></li>
  <li><strong>Display.DisplayObjContainer</strong></li>
  <li><a href="../modules/Display.DisplayObjTransform.html">Display.DisplayObjTransform</a></li>
  <li><a href="../modules/Display.DrawableObject.html">Display.DrawableObject</a></li>
  <li><a href="../modules/Display.Image.html">Display.Image</a></li>
  <li><a href="../modules/Display.MovieClip.html">Display.MovieClip</a></li>
  <li><a href="../modules/Display.Quad.html">Display.Quad</a></li>
  <li><a href="../modules/Display.Stage.html">Display.Stage</a></li>
  <li><a href="../modules/Display.TextField.html">Display.TextField</a></li>
  <li><a href="../modules/Display.TileMap.html">Display.TileMap</a></li>
  <li><a href="../modules/include.html">include</a></li>
  <li><a href="../modules/Texture.ITextureAtlas.html">Texture.ITextureAtlas</a></li>
  <li><a href="../modules/Texture.SubTexture.html">Texture.SubTexture</a></li>
  <li><a href="../modules/Texture.Texture.html">Texture.Texture</a></li>
  <li><a href="../modules/Texture.TextureAtlas.html">Texture.TextureAtlas</a></li>
  <li><a href="../modules/Texture.TextureAtlasComposer.html">Texture.TextureAtlasComposer</a></li>
  <li><a href="../modules/Texture.TextureManager.html">Texture.TextureManager</a></li>
  <li><a href="../modules/Texture.TexturePacker.html">Texture.TexturePacker</a></li>
  <li><a href="../modules/TileSet.ITileSet.html">TileSet.ITileSet</a></li>
  <li><a href="../modules/TileSet.Tile.html">TileSet.Tile</a></li>
  <li><a href="../modules/TileSet.TileSet.html">TileSet.TileSet</a></li>
  <li><a href="../modules/TileSet.TileSetComposer.html">TileSet.TileSetComposer</a></li>
  <li><a href="../modules/Tween.Bezier.html">Tween.Bezier</a></li>
  <li><a href="../modules/Tween.DisplayObjTweener.html">Tween.DisplayObjTweener</a></li>
  <li><a href="../modules/Tween.Transition.html">Tween.Transition</a></li>
  <li><a href="../modules/Tween.Tween.html">Tween.Tween</a></li>
  <li><a href="../modules/Tween.TweenBezier.html">Tween.TweenBezier</a></li>
  <li><a href="../modules/Tween.TweenDelay.html">Tween.TweenDelay</a></li>
  <li><a href="../modules/Tween.TweenEase.html">Tween.TweenEase</a></li>
  <li><a href="../modules/Tween.TweenLoop.html">Tween.TweenLoop</a></li>
  <li><a href="../modules/Tween.TweenParallel.html">Tween.TweenParallel</a></li>
  <li><a href="../modules/Tween.TweenSequence.html">Tween.TweenSequence</a></li>
  <li><a href="../modules/Utils.BitOp.html">Utils.BitOp</a></li>
  <li><a href="../modules/Utils.Callbacks.html">Utils.Callbacks</a></li>
  <li><a href="../modules/Utils.ClassEx.html">Utils.ClassEx</a></li>
  <li><a href="../modules/Utils.CollisionKit.html">Utils.CollisionKit</a></li>
  <li><a href="../modules/Utils.Color.html">Utils.Color</a></li>
  <li><a href="../modules/Utils.Coroutines.html">Utils.Coroutines</a></li>
  <li><a href="../modules/Utils.IniFile.html">Utils.IniFile</a></li>
  <li><a href="../modules/Utils.IniParser.html">Utils.IniParser</a></li>
  <li><a href="../modules/Utils.IO.html">Utils.IO</a></li>
  <li><a href="../modules/Utils.Log.html">Utils.Log</a></li>
  <li><a href="../modules/Utils.Math.html">Utils.Math</a></li>
  <li><a href="../modules/Utils.PerformanceTimer.html">Utils.PerformanceTimer</a></li>
  <li><a href="../modules/Utils.Polygon.html">Utils.Polygon</a></li>
  <li><a href="../modules/Utils.Shape.html">Utils.Shape</a></li>
  <li><a href="../modules/Utils.Sound.html">Utils.Sound</a></li>
  <li><a href="../modules/Utils.String.html">Utils.String</a></li>
  <li><a href="../modules/Utils.StringBuilder.html">Utils.StringBuilder</a></li>
  <li><a href="../modules/Utils.Table.html">Utils.Table</a></li>
  <li><a href="../modules/Utils.Vector.html">Utils.Vector</a></li>
  <li><a href="../modules/Utils.XmlNode.html">Utils.XmlNode</a></li>
  <li><a href="../modules/Utils.XmlParser.html">Utils.XmlParser</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>Display.DisplayObjContainer</code></h1>
<p>A DisplayObjectContainer represents a collection of display objects.</p>
<p>

It is the base class of all display objects that act as a container

for other objects. By maintaining an ordered list of children, it

defines the back-to-front positioning of the children within the

display tree.



A container does not a have size in itself. The width and height

properties represent the extents of its children.



- Adding and removing children



The class defines methods that allow you to add or remove children.



When you add a child, it will be added at the frontmost position,

possibly occluding a child that was added before.
</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#children">children (displayObjContainer, typeFilter)</a></td>
	<td class="summary">iterator for DisplayObjContainer children.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#reverse_children">reverse_children (displayObjContainer, typeFilter)</a></td>
	<td class="summary">Reverse iterator for DisplayObjContainer children.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#init">init ()</a></td>
	<td class="summary">Initialization method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#dispose">dispose ()</a></td>
	<td class="summary">When an objectContainer is disposed it realease all his children.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#dbgInfo">dbgInfo (recursive)</a></td>
	<td class="summary">Debug Infos</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#drawOrientedBounds">drawOrientedBounds ()</a></td>
	<td class="summary">Draws oriented bounds for all his children</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#drawAABounds">drawAABounds (drawContainer)</a></td>
	<td class="summary">Draws axis aligned bounds for all his children.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getChildByName">getChildByName (name)</a></td>
	<td class="summary">Returns the first child with a given name, if it exists, or nil</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#_innerRemoveChild">_innerRemoveChild (obj)</a></td>
	<td class="summary">Inner method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#addChild">addChild (obj)</a></td>
	<td class="summary">Add a displayObj to the children list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#removeChild">removeChild (obj, dispose)</a></td>
	<td class="summary">Remove an obj from children list.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getNumChildren">getNumChildren ()</a></td>
	<td class="summary">Return the number of children</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#addChildAt">addChildAt (obj, index)</a></td>
	<td class="summary">Add a child at given position</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#removeChildAt">removeChildAt (index, dispose)</a></td>
	<td class="summary">Remove a child at a given position</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#removeChildren">removeChildren (beginIndex, endIndex, dispose)</a></td>
	<td class="summary">Remove all the children between two indices</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getChildIndex">getChildIndex (obj)</a></td>
	<td class="summary">Returns the index of a given displayObj, if contained, or 0 if not.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getChildAt">getChildAt (index)</a></td>
	<td class="summary">Returns the displayObj at the given index.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#swapChildren">swapChildren (obj1, obj2)</a></td>
	<td class="summary">Swap two given children in the displayList.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#swapChildrenAt">swapChildrenAt (index1, index2)</a></td>
	<td class="summary">Swap two children at given positions in the displayList

If both the indices are valid, swap the relative objects</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setAlpha">setAlpha (a)</a></td>
	<td class="summary">Set container alpha value</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#_setMultiplyColor">_setMultiplyColor (r, g, b, a)</a></td>
	<td class="summary">Inner method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#_updateChildrenColor">_updateChildrenColor ()</a></td>
	<td class="summary">Inner method.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setHittable">setHittable (hittable)</a></td>
	<td class="summary">By default the hitTet over a DisplayObjContainer is an hitTest over

all its children.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#isHittable">isHittable ()</a></td>
	<td class="summary">Returns if a DisplayObjContainer can be direct target of a touch event</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setVisible">setVisible (visible)</a></td>
	<td class="summary">Change visibility status of the container</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getRect">getRect (resultRect)</a></td>
	<td class="summary">Return a rect obtained by children rect

Iterates over all the children and calculates a rectangle that enclose them all.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#hitTest">hitTest (x, y, targetSpace, forTouch)</a></td>
	<td class="summary">Given a x,y point in targetSpace coordinates it check if it falls inside local bounds.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#createFrameBufferImage">createFrameBufferImage (bUpdate, width, height)</a></td>
	<td class="summary">The method led to create an image that will be rendered in place of the whole

displaylist owned by the container.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#destroyFrameBufferImage">destroyFrameBufferImage ()</a></td>
	<td class="summary">Removes the frameBufferImage previously created with a createFrameBufferImage call and restores

normal draw of the container.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getFrameBufferImage">getFrameBufferImage ()</a></td>
	<td class="summary">Returns the frameBufferImage previously created with a createFrameBufferImage call</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#flatten">flatten (w, h)</a></td>
	<td class="summary">alias for createFrameBufferImage call with bUpdate = false

Takes the name from original Starling sprite:flatten logic</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#unflatten">unflatten ()</a></td>
	<td class="summary">alias for destroyFrameBufferImage call

Takes the name from original Starling sprite:unflatten logic</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#isFlattened">isFlattened ()</a></td>
	<td class="summary">Check if a frameBufferData is present with isFlattened = true</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setClipArea">setClipArea (w, h)</a></td>
	<td class="summary">alias for createFrameBufferImage call with dynamic update set to true</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#destroyClipArea">destroyClipArea ()</a></td>
	<td class="summary">alias for destroyFrameBufferImage call

Takes the name from original Starling sprite:unflatten logic</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#hasClipArea">hasClipArea ()</a></td>
	<td class="summary">Check if a frameBufferData is present with isFlattened = false (so dynamic)</td>
	</tr>
</table>
<h2><a href="#Fields">Fields</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#__defaultUseMultiplyColor">__defaultUseMultiplyColor</a></td>
	<td class="summary">DisplayObjContainers must notify all interested children into color changes so to be able

to correctly react to the events.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "children"></a>
    <strong>children (displayObjContainer, typeFilter)</strong>
    </dt>
    <dd>
    iterator for DisplayObjContainer children.

It's possible to retrieve only children of a given 'typeFilter' type



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">displayObjContainer</span>
         the container of which children must be iterated
        </li>
        <li><span class="parameter">typeFilter</span>
         filter on the type of the children
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        next iterator
    </ol>




</dd>
    <dt>
    <a name = "reverse_children"></a>
    <strong>reverse_children (displayObjContainer, typeFilter)</strong>
    </dt>
    <dd>
    Reverse iterator for DisplayObjContainer children.

It's possible to retrieve only children of a given 'typeFilter' type



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">displayObjContainer</span>
         the container of which children must be iterated
        </li>
        <li><span class="parameter">typeFilter</span>
         filter on the type of the children
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        next (reverse) iterator
    </ol>




</dd>
    <dt>
    <a name = "init"></a>
    <strong>init ()</strong>
    </dt>
    <dd>
    Initialization method.

Children displayObj list is built as well as objRenderTalbe list.








</dd>
    <dt>
    <a name = "dispose"></a>
    <strong>dispose ()</strong>
    </dt>
    <dd>
    When an objectContainer is disposed it realease all his children.

All the children are themself disposed








</dd>
    <dt>
    <a name = "dbgInfo"></a>
    <strong>dbgInfo (recursive)</strong>
    </dt>
    <dd>
    Debug Infos


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">recursive</span>
         boolean, if true dbgInfo will be called also for all the children
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        string
    </ol>




</dd>
    <dt>
    <a name = "drawOrientedBounds"></a>
    <strong>drawOrientedBounds ()</strong>
    </dt>
    <dd>
    Draws oriented bounds for all his children







</dd>
    <dt>
    <a name = "drawAABounds"></a>
    <strong>drawAABounds (drawContainer)</strong>
    </dt>
    <dd>
    Draws axis aligned bounds for all his children.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">drawContainer</span>
         boolean, if true also container bounds will be drawn
        </li>
    </ul>





</dd>
    <dt>
    <a name = "getChildByName"></a>
    <strong>getChildByName (name)</strong>
    </dt>
    <dd>
    Returns the first child with a given name, if it exists, or nil


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">name</span>
         of the child to be searched
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        displayObj or nil
    </ol>




</dd>
    <dt>
    <a name = "_innerRemoveChild"></a>
    <strong>_innerRemoveChild (obj)</strong>
    </dt>
    <dd>
    Inner method.

Used to remove a children by the container without setting the new father.

It's used either from removeChild than from addChild for object already added

to another container



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj</span>
         the obj to remove
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        obj if removed or nil
    </ol>




</dd>
    <dt>
    <a name = "addChild"></a>
    <strong>addChild (obj)</strong>
    </dt>
    <dd>
    Add a displayObj to the children list.

The child is add at the end of the children list so it's the top most of the drawn children.

If the obj already has a parent, first is removed from the parent and then added to the new

parent container.



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj</span>
         the obj to be added as child
        </li>
    </ul>





</dd>
    <dt>
    <a name = "removeChild"></a>
    <strong>removeChild (obj, dispose)</strong>
    </dt>
    <dd>
    Remove an obj from children list.

if the object is not a child do nothing



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj</span>
         the obj to be removed
        </li>
        <li><span class="parameter">dispose</span>
         if to dispose after removal
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the obj if removed, nil if the obj is not a child
    </ol>




</dd>
    <dt>
    <a name = "getNumChildren"></a>
    <strong>getNumChildren ()</strong>
    </dt>
    <dd>
    Return the number of children



    <h3>Returns:</h3>
    <ol>

        size of displayObj list
    </ol>




</dd>
    <dt>
    <a name = "addChildAt"></a>
    <strong>addChildAt (obj, index)</strong>
    </dt>
    <dd>
    Add a child at given position


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj</span>
         the obj o be added
        </li>
        <li><span class="parameter">index</span>
         the desired position
        </li>
    </ul>





</dd>
    <dt>
    <a name = "removeChildAt"></a>
    <strong>removeChildAt (index, dispose)</strong>
    </dt>
    <dd>
    Remove a child at a given position


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
         the position of the obj to be removed
        </li>
        <li><span class="parameter">dispose</span>
         boolean, if to dispose the obj after removal
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the obj if the index is valid or nil
    </ol>




</dd>
    <dt>
    <a name = "removeChildren"></a>
    <strong>removeChildren (beginIndex, endIndex, dispose)</strong>
    </dt>
    <dd>
    Remove all the children between two indices


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">beginIndex</span>
         index of the first object to be removed
        </li>
        <li><span class="parameter">endIndex</span>
         index of the last object to be removed
        </li>
        <li><span class="parameter">dispose</span>
         if to dispose the objects after removal
        </li>
    </ul>





</dd>
    <dt>
    <a name = "getChildIndex"></a>
    <strong>getChildIndex (obj)</strong>
    </dt>
    <dd>
    Returns the index of a given displayObj, if contained, or 0 if not.



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj</span>
         the obj to be searched
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        obj position in children list or 0 if obj is not a child
    </ol>




</dd>
    <dt>
    <a name = "getChildAt"></a>
    <strong>getChildAt (index)</strong>
    </dt>
    <dd>
    Returns the displayObj at the given index.



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index</span>
         the index of the obj to be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the obj at position 'index' or nil if it doesn't exist
    </ol>




</dd>
    <dt>
    <a name = "swapChildren"></a>
    <strong>swapChildren (obj1, obj2)</strong>
    </dt>
    <dd>
    Swap two given children in the displayList.

If both the object are children, swap the positions



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">obj1</span>
         first object to be moved
        </li>
        <li><span class="parameter">obj2</span>
         second object to be moved
        </li>
    </ul>





</dd>
    <dt>
    <a name = "swapChildrenAt"></a>
    <strong>swapChildrenAt (index1, index2)</strong>
    </dt>
    <dd>
    Swap two children at given positions in the displayList

If both the indices are valid, swap the relative objects


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">index1</span>
         index of the first object to be moved
        </li>
        <li><span class="parameter">index2</span>
         index of the second object to be moved
        </li>
    </ul>





</dd>
    <dt>
    <a name = "setAlpha"></a>
    <strong>setAlpha (a)</strong>
    </dt>
    <dd>
    Set container alpha value


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">a</span>
         [0,255]
        </li>
    </ul>





</dd>
    <dt>
    <a name = "_setMultiplyColor"></a>
    <strong>_setMultiplyColor (r, g, b, a)</strong>
    </dt>
    <dd>
    Inner method.  Called by parent container, setMultiplyAlpha set the alpha value of the parent container (already

modified by his current multiplyalpha value)



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">r</span>
         [0,1]
        </li>
        <li><span class="parameter">g</span>
         [0,1]
        </li>
        <li><span class="parameter">b</span>
         [0,1]
        </li>
        <li><span class="parameter">a</span>
         [0,1]
        </li>
    </ul>





</dd>
    <dt>
    <a name = "_updateChildrenColor"></a>
    <strong>_updateChildrenColor ()</strong>
    </dt>
    <dd>
    Inner method.  Propagate color value to all children, setting "multiplied color" value

used by object that need it for correct displaying using pixel shaders








</dd>
    <dt>
    <a name = "setHittable"></a>
    <strong>setHittable (hittable)</strong>
    </dt>
    <dd>
    By default the hitTet over a DisplayObjContainer is an hitTest over

all its children.  It's possible anyway to set itself as target of

an hitTest, without going deep in the displayList

--@param hittable boolean



    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">hittable</span>

        </li>
    </ul>





</dd>
    <dt>
    <a name = "isHittable"></a>
    <strong>isHittable ()</strong>
    </dt>
    <dd>
    Returns if a DisplayObjContainer can be direct target of a touch event



    <h3>Returns:</h3>
    <ol>

        boolean
    </ol>




</dd>
    <dt>
    <a name = "setVisible"></a>
    <strong>setVisible (visible)</strong>
    </dt>
    <dd>
    Change visibility status of the container


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">visible</span>
         boolean
        </li>
    </ul>





</dd>
    <dt>
    <a name = "getRect"></a>
    <strong>getRect (resultRect)</strong>
    </dt>
    <dd>
    Return a rect obtained by children rect

Iterates over all the children and calculates a rectangle that enclose them all.


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">resultRect</span>
         it's possibile to pass a Rect helper to store results
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a rect filled with bound infos
    </ol>




</dd>
    <dt>
    <a name = "hitTest"></a>
    <strong>hitTest (x, y, targetSpace, forTouch)</strong>
    </dt>
    <dd>
    Given a x,y point in targetSpace coordinates it check if it falls inside local bounds.

If the container is set as hittable, the hitTest will be done only on its own boundary

without testing all the children, and the resulting target will be itself. If not

hittable instead, the hitTest will be done on children, starting from then topmost

displayObjContainer.





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">x</span>
         coordinate in targetSpace system
        </li>
        <li><span class="parameter">y</span>
         coordinate in targetSpace system
        </li>
        <li><span class="parameter">targetSpace</span>
         the referred coorindate system. if nil the top most container / stage
        </li>
        <li><span class="parameter">forTouch</span>
         boolean. If true the check is done only for visible and touchable object
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        self if the hitTest is positive else nil
    </ol>




</dd>
    <dt>
    <a name = "createFrameBufferImage"></a>
    <strong>createFrameBufferImage (bUpdate, width, height)</strong>
    </dt>
    <dd>
    The method led to create an image that will be rendered in place of the whole

displaylist owned by the container.



That can be used for different purposes:



1) to optimize the rendering of a displayList composed of only static objects.

If bUpdate is false or nil in fact, all the children attached to the container are

rendered once to an image then used as unique displayObj. That can lead

to a performance increase when the container is made of several static objects.

The draw back is that the rendering is never updated since a new call to createFrameBufferImage

or since a call to destroyFrameBufferImage. That means that even if a child is removed,

set invisible or transofrmed the rendering will shows the state of the container at the moment of the

image creation. It's possible to specify the size of the area that will be draw (things outside

will be clipped out). If no width/height are provided then container width / height are used

(with a maximum of 2048x2048)



Very important: the draw of the image will happen next frame, so every change done during the same

frame of the call will be applied even if done after the call.



The logic is similar to Starling flatten / unflatten logic and for that a couple of method with

this name are provided as alias.



2) To create a clip area of given width / height.

If bUpdate is true, an image is created but the rendering is updated each frame.

That lead to a decrease in performance because the normal rendering has to be done and moreover

a new texture has to be rendered. The good news is that now we're able to clip a container

like when using scissor but without the limitation of the scissor of being axis aligned.





An important thing about having a container transformed into an image is that it allows to apply shaders

transformation to the resulting image, and so to a whole display scene.



NB: the frameBufferImage is always built on a rect that has point (0,0) coincindent with the point (0,0)

of the container.





    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bUpdate</span>
         defines if the frameBufferImage will be dynamically updated each frame or created once

and no more update (flatten)
        </li>
        <li><span class="parameter">width</span>
         width of the frameBufferImage. Default value is the width of the container. Max = 2048
        </li>
        <li><span class="parameter">height</span>
         height of the frameBufferImage. Default value is the height of the container. Max = 2048
        </li>
    </ul>





</dd>
    <dt>
    <a name = "destroyFrameBufferImage"></a>
    <strong>destroyFrameBufferImage ()</strong>
    </dt>
    <dd>
    Removes the frameBufferImage previously created with a createFrameBufferImage call and restores

normal draw of the container.







</dd>
    <dt>
    <a name = "getFrameBufferImage"></a>
    <strong>getFrameBufferImage ()</strong>
    </dt>
    <dd>
    Returns the frameBufferImage previously created with a createFrameBufferImage call



    <h3>Returns:</h3>
    <ol>

        framBufferImage or nil
    </ol>




</dd>
    <dt>
    <a name = "flatten"></a>
    <strong>flatten (w, h)</strong>
    </dt>
    <dd>
    alias for createFrameBufferImage call with bUpdate = false

Takes the name from original Starling sprite:flatten logic


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">w</span>
         width of the flattened area (that always begin in 0,0)
        </li>
        <li><span class="parameter">h</span>
         height of the flattened area (that always begin in 0,0)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "unflatten"></a>
    <strong>unflatten ()</strong>
    </dt>
    <dd>
    alias for destroyFrameBufferImage call

Takes the name from original Starling sprite:unflatten logic







</dd>
    <dt>
    <a name = "isFlattened"></a>
    <strong>isFlattened ()</strong>
    </dt>
    <dd>
    Check if a frameBufferData is present with isFlattened = true



    <h3>Returns:</h3>
    <ol>

        bool
    </ol>




</dd>
    <dt>
    <a name = "setClipArea"></a>
    <strong>setClipArea (w, h)</strong>
    </dt>
    <dd>
    alias for createFrameBufferImage call with dynamic update set to true


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">w</span>
         width of the clip area (that always begin in 0,0)
        </li>
        <li><span class="parameter">h</span>
         height of the clip area (that always begin in 0,0)
        </li>
    </ul>





</dd>
    <dt>
    <a name = "destroyClipArea"></a>
    <strong>destroyClipArea ()</strong>
    </dt>
    <dd>
    alias for destroyFrameBufferImage call

Takes the name from original Starling sprite:unflatten logic







</dd>
    <dt>
    <a name = "hasClipArea"></a>
    <strong>hasClipArea ()</strong>
    </dt>
    <dd>
    Check if a frameBufferData is present with isFlattened = false (so dynamic)



    <h3>Returns:</h3>
    <ol>

        bool
    </ol>




</dd>
</dl>
    <h2><a name="Fields"></a>Fields</h2>
    <dl class="function">
    <dt>
    <a name = "__defaultUseMultiplyColor"></a>
    <strong>__defaultUseMultiplyColor</strong>
    </dt>
    <dd>
    DisplayObjContainers must notify all interested children into color changes so to be able

to correctly react to the events.  Used mainly by children objects drawn using pixel shader

(like quads)

Disabling multiplyColor calling useMultiplyColor() makes possible to optimize DisplayObjContainer

color / alpha management, but only if sure that no children are using multiplyColor feature








</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
